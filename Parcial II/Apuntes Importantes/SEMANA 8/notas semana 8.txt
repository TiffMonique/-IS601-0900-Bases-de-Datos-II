
--Procedimeentos almacenados
CREATE OR REPLACE PROCEDURE <NOMBRE PROCEDIMIENTO>(<PARAMETROS>)

--Bloque anonimo
DECLARE 
    <DECLARACION DE VARIABLES>
BEGIN
    <INSTRUCCIONES SQL>
END;


****Cambios

CREATE OR REPLACE PROCEDURE <NOMBRE PROCEDIMIENTO>(<PARAMETROS>)

IS 
    <DECLARACION DE VARIABLES>
BEGIN
    <INSTRUCCIONES SQL>
END;


DECLARACION DE PARAMETROS
<NOMBRE PARAMETRO> IN|OUT|IN OUT <TIPO DE DATO>
EJEMPLO
NOMBRE VARCHAR2

IN: si declaramos un parametro de tipo IN lo vamos a utilizar para recibir valores, y no lo podemos modificar en la parte de BEGIN
OUT: si declaramos un parametro de tipo OUT significa que vamos a utilizar ese parametro solamente para poder modificar su valor en el cuerpo del procedimiento y para que ese precedimiento pueda retornar un valor
IN OUT: sig que ese parametro puede recibir valores , y se pueden modificar en el cuerpo del procedimiento y retornarse


---CREAR PROCEDIMIENTO ALMACENADO SP(STORED PROCEDURE) OBTENER EL NOMBRE DE LAS CATEGORIAS E IMPRIMIR EL VALOR OBTENIDO
---EL ONMBRE SE DEBE OBTENER DE LA CATEGORIA =2

CREATE OR REPLACE PROCEDURE SP_OBTENER_NOMB_CAT (IDCAT IN NUMBER)
IS

    NOMBRE_CAT CATEGORIES.CATEGORY_NAME%TYPE;
BEGIN
    SELECT CATEGORIES.CATEGORY_NAME INTO NOMBRE_CAT FROM CATEGORIES WHERE CATEGORY_ID=IDCAT;
    DBMS_OUTPUT.PUT_LINE('EL NOMBRE DE LA CATEGORIA ES: '||NOMBRE_CATE)
END;

--Para ejecutar nuestro procedimiento
//Forma #1
EXECUTE SP_OBTENER_NOMB_CAT(2);

//Forma #2
BEGIN   
    SP_OBTENER_NOMB_CAT
END;



--OTRA FROMA DE REALIZARLO
CREATE OR REPLACE PROCEDURE SP_OBTENER_NOMB_CAT (IDCAT IN NUMBER, NOMBRE_CAT OUT CATEGORIES.CATEGORY_NAME%TYPE)

IS

BEGIN
    SELECT CATEGORIES.CATEGORY_NAME INTO NOMBRE_CAT FROM CATEGORIES WHERE CATEGORY_ID=IDCAT;
    
END;



DECLARE
    NOMBRE_CATEGORIA CATEGORIES.CATEGORY_NAME%TYPE;

BEGIN
    SP_OBTENER_NOMB_CAT(2, NOMBRE_CATEGORIA);
    DBMS_OUTPUT.PUT_LINE('EL NOMBRE DE LA CATEGORIA ES: '||NOMBRE_CATEGORIA);
END;


---UTILIZACION DE IN OUT
CREATE OR REPLACE PROCEDURE SP_OBTENER_NOMB_CAT (IDCAT IN NUMBER, NOMBRE_CAT IN OUT CATEGORIES.CATEGORY_NAME%TYPE)

IS

BEGIN
    SELECT CATEGORIES.CATEGORY_NAME INTO NOMBRE_CAT FROM CATEGORIES WHERE CATEGORY_ID=IDCAT;
    
END;



DECLARE
    NOMBRE_CATEGORIA CATEGORIES.CATEGORY_NAME%TYPE=:'VALOR ANTES DE LLAMAR AL SP';

BEGIN
    DBMS_OUTPUT.PUT_LINE('EL NOMBRE DE LA CATEGORIA ES: '||NOMBRE_CATEGORIA);
    SP_OBTENER_NOMB_CAT(2, NOMBRE_CATEGORIA);
    DBMS_OUTPUT.PUT_LINE('EL NOMBRE DE LA CATEGORIA ES: '||NOMBRE_CATEGORIA);
END;

-------------CLASE 5: INTRODUCCION A SP (PARTE B)-----------------
***UN PROCEDIMIENTO ALMACENADO NO NECESARIAMENTE PUEDE RECIBIR PARAMETROS

--Crear un SP que obtenga la cantidad total de productos

CREATE OR REPLACE PROCEDURE SP_CANT_PRODUCTOS

IS
    CANTIDAD NUMBER;
BEGIN
    SELECT COUNT(*) INTO CANTIDAD FROM PRODUCTS;
    DBMS_OUTPUT.PUT_LINE('LA CANTIDAD DE PRODUCTOS GUARDADOS ES: '||CANTIDAD);
END;

---Para ejecutar
EXECUTE SP_CANT_PRODUCTOS;



----INTRODUCCION A SP

CREATE OR REPLACE PROCEDURE SP_INSERTA_PRODUCTO(NOMB_PROD VARCHAR,ID_BRAND NUMBER, CAT_ID NUMBER, 
                                                ANIO_MODELO NUMBER, PRECIO NUMBER, MSJ_ERROR OUT VARCHAR2,
                                                MSJ_EXITO OUT VARCHAR2)
IS
    VAL_MAX_PROD_ID NUMBER;                                        
                                                
BEGIN
---CONTROLAR CUAL ES EL VALOR MAXIMO 
    SELECT (MAX(PRODUCT_ID)+1) INTO VAL_MAX_PROD_ID FROM PRODUCTS;
----Realizar el insert dentro de la tabla
    INSERT INTO PRODUCTS VALUES(VAL_MAX_PROD_ID, NOMB_PROD, ID_BRAND, CAT_ID , ANIO_MODELO, PRECIO);
-----HACER COMMIT SI LA INSERCION SE AGREGO DE LA FORMA CORRECTA
    COMMIT;
---PARA SABER SI SE EJECEUTO DE FOMA EXITOSA
    MSJ_EXITO:='LA INSERCION DEL PRODUCTO FUE EXITOSA';

------CONTROLOAR ERRORES DE LINEA 10 A TRAVES DE EXCEPCIONES
    EXCEPTION 
        WHEN OTHERS THEN 
            MSJ_ERROR:=SQLERRM;
            
END;

***COMO VOY A HACER USO DEL PROCEDIMIENTO
--A TRAVES DE UN BLOQUE anonimo

DECLARE 
    MSJ_ERROR VARCHAR2(500);
    MSJ_EXITO VARCHAR(500);

BEGIN
    SP_INSERTA_PRODUCTO('BICICLETA DE MONTAÃ±A', 1,2,2019,4345, MSJ_ERROR, MSJ_EXITO);
    DBMS_OUTPUT.PUT_LINE(MSJ_EXITO||' '||MSJ_ERROR);

END;

---CREACION DE SECUENCIA O TRIGGER PARA HACER CAMBIOS EN EL PROCEDIMIENTO

CREATE SEQUENCE SQ_PRODUCTS
START WITH 323
INCREMENT BY 1;

CREATE OR REPLACE TRIGGER TG_SQ_PRODUCTS
BEFORE INSERT ON PRODUCTS
FOR EACH ROW

DECLARE

BEGIN
    :NEW.PRODUCT_ID:=SQ_PRODUCTS.NEXTVAL;
END;


---QUE CAMBIOS VOY A HACER EN EL PROCEDIMIENTO
//ya tenemos un TRIGGER que gestiona  una secuencia para el valor de la llave primaria
la consulta SELECT (MAX(PRODUCT_ID)+1)..... YA NO SE NECESITA EN EL BEGIN
Tampoco se necesita la variable dentro del IS VAL_MAX_PROD_ID



CREATE OR REPLACE PROCEDURE SP_INSERTA_PRODUCTO(NOMB_PROD VARCHAR,ID_BRAND NUMBER, CAT_ID NUMBER, 
                                                ANIO_MODELO NUMBER, PRECIO NUMBER, MSJ_ERROR OUT VARCHAR2,
                                                MSJ_EXITO OUT VARCHAR2)
IS                                      
                                                
BEGIN

----Realizar el insert dentro de la tabla
    INSERT INTO PRODUCTS VALUES  (PRODUCT_NAME, BRAND_ID, CATEGORY_ID, MODEL_YEAR, LIST_PRICE)  (NOMB_PROD, ID_BRAND, CAT_ID , ANIO_MODELO, PRECIO);
-----HACER COMMIT SI LA INSERCION SE AGREGO DE LA FORMA CORRECTA
    COMMIT;
---PARA SABER SI SE EJECEUTO DE FOMA EXITOSA
    MSJ_EXITO:='LA INSERCION DEL PRODUCTO FUE EXITOSA';

------CONTROLOAR ERRORES DE LINEA 10 A TRAVES DE EXCEPCIONES
    EXCEPTION 
        WHEN OTHERS THEN 
            MSJ_ERROR:=SQLERRM;
            
END;

*********************************

----Cuando no existe el ID_BRAND o CAT_ID lo que hacemos es controlarlo por medio de EXCEPCIONES
pero lo que podemos hacer al ver esos valores, podemos verificar que ese valor EXista si ese valor existe, permite la 
ejecucion del procedimiento y si no simplemente insertar el valor.

lo vamos a controlar por el valor de la llave primaria, si no existe lo vamos a insertar

----hacer un conteo  de la cantidad de registros de la tabla brands , donde sea igual al valor que se esta recibiendo

...

CREATE OR REPLACE PROCEDURE SP_INSERTA_PRODUCTO(NOMB_PROD VARCHAR,ID_BRAND  IN  NUMBER , CAT_ID NUMBER,
                                                ANIO_MODELO NUMBER, PRECIO NUMBER, NOMBRE_BRAND VARCHAR2,  MSJ_ERROR OUT VARCHAR2,
                                                MSJ_EXITO OUT VARCHAR2)
IS                               
    CANTIDAD_REGISTROS NUMBER;
    COD_BRAND NUMBER;
BEGIN

---SABER SI EXISTE EL VALOR O NO
    SELECT COUNT(*) INTO CANTIDAD_REGISTROS FROM BRANDS WHERE BRAND_ID = ID_BRAND; 
    
    
    IF (CANTIDAD_REGISTROS=1) THEN 
    ----Realizar el insert dentro de la tabla
        INSERT INTO PRODUCTS (PRODUCT_NAME, BRAND_ID, CATEGORY_ID, MODEL_YEAR, 
        LIST_PRICE) VALUES  (NOMB_PROD, ID_BRAND, CAT_ID , ANIO_MODELO, PRECIO);
    ----HACER COMMIT SI LA INSERCION SE AGREGO DE LA FORMA CORRECTA
        COMMIT;
    ---PARA SABER SI SE EJECEUTO DE FOMA EXITOSA
        MSJ_EXITO:='LA INSERCION DEL PRODUCTO FUE EXITOSA';
    

    ELSE 
        SP_INSERTA_BRAND(NOMBRE_BRAND, COD_BRAND);
        INSERT INTO PRODUCTS (PRODUCT_NAME, BRAND_ID, CATEGORY_ID, MODEL_YEAR, 
        LIST_PRICE) VALUES  (NOMB_PROD,COD_BRAND, CAT_ID , ANIO_MODELO, PRECIO);
    ----HACER COMMIT SI LA INSERCION SE AGREGO DE LA FORMA CORRECTA
        COMMIT;
    ---PARA SABER SI SE EJECEUTO DE FOMA EXITOSA
        MSJ_EXITO:='LA INSERCION DEL PRODUCTO FUE EXITOSA';
     
    END IF;
    
-----CONTROLOAR ERRORES DE LINEA 10 A TRAVES DE EXCEPCIONES
    EXCEPTION 
        WHEN OTHERS THEN 
            MSJ_ERROR:=SQLERRM;
            
END;


----crear el brand
//lo unico que necesita recibir es el nombre que queremos asignar al brand
CREATE OR REPLACE PROCEDURE SP_INSERTA_BRAND(NOMBRE_BRAND VARCHAR2, ID_BRAND OUT NUMBER)

IS

BEGIN 

    INSERT INTO BRANDS (BRAND_NAME) VALUES (NOMBRE_BRAND);
    SELECT BRAND_ID INTO ID_BRAND FROM BRANDS WHERE BRAND_NAME = NOMBRE_BRAND;
    COMMIT;

END;

---Crear la secuencia
CREATE SEQUENCE SQ_BRAND
START WITH 10
INCREMENT BY 1;

CREATE OR REPLACE TRIGGER TG_SQ_BRANDS
BEFORE INSERT ON BRANDS
FOR EACH ROW

DECLARE

BEGIN
    :NEW.BRAND_ID:=SQ_BRAND.NEXTVAL;
END;


Si el brand no existe, lo insertamos haciendo el llamadao de un procedimiento hacia otro procedimiento
que es otro procedimiento se encargue de insertar ese brand





----------------Clase 8-----------------
Ejercicio de procedimiento de la tabla staff

Esa tabla hace una referencia a ella misma a traves de una llave foranea, a tra ves del campo manager ID_manager

crearemos dos procedimientos 
1. envia los parametros necesarios para insertar un registro en la tabla staff
2. se encargara de hace la Insercion de estos registros en la tabla mencionada


-----PROCEDIMENTO PRINCIPAL
CREATE OR REPLACE PROCEDURE SP_VALORES_REG_STAFF(ID_STAFF NUMBER , PRIM_NOMBRE VARCHAR2, APELLIDO VARCHAR2, CORREO VARCHAR2, 
                                                TELEFONO VARCHAR2, REG_ACTIVO NUMBER, ID_STORE NUMBER, ID_MANAGER NUMBER, MSJ OUT NUMBER)

IS

    MSJ NUMBER;

BEGIN

    SP_INSERT_STAFFS(ID_STAFF , PRIM_NOMBRE, APELLIDO , CORREO ,  TELEFONO , REG_ACTIVO , ID_STORE, ID_MANAGER, MSJ );
    INSERT INTO BITACORAS (DESCRIPCION, FECHA, OPERACION, USUARIO) VALUES ('Se inserto un registro en la tabla STAFF', sysdate, 'INSERT', user);
    
    IF (MSJ=1) THEN
        COMMIT;
   
    ELSIF (MSJ=2) THEN
        ROLLBACK;
    
    END IF;

END;



----PROCEDIMIENTO SECUNDARIO
    CREATE OR REPLACE PROCEDURE SP_INSERT_STAFFS(ID_STAFF NUMBER , PRIM_NOMBRE VARCHAR2, APELLIDO VARCHAR2, CORREO VARCHAR2, 
                                                TELEFONO VARCHAR2, REG_ACTIVO NUMBER, ID_STORE NUMBER, ID_MANAGER NUMBER, MSJ OUT NUMBER)

IS

BEGIN

    INSERT INTO STAFFS VALUES (ID_STAFF ,PRIM_NOMBRE ,APELLIDO ,CORREO ,TELEFONO , REG_ACTIVO , ID_STORE , ID_MANAGER);
    MSJ:=1;
    
    
    EXCEPTION
        WHEN OTHERS THEN
        MSJ:=2;
END;











